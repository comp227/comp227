{"componentChunkName":"component---src-templates-content-template-js","path":"/part8/background_and_introduction","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p><a href=\"https://www.typescriptlang.org/\">TypeScript</a> is a programming language designed for large-scale JavaScript development created by Microsoft.\nFor example, Microsoft's <a href=\"https://github.com/Azure/api-management-developer-portal\"><em>Azure Management Portal</em></a> (1.2 million lines of code)\nand <a href=\"https://github.com/microsoft/vscode\"><em>Visual Studio Code</em></a> (300k lines of code) have both been written in TypeScript.\nTo support building large-scale JavaScript applications, TypeScript offers features such as:</p>\n<ul>\n<li>better development-time tooling</li>\n<li>static code analysis</li>\n<li>compile-time type checking</li>\n<li>code-level documentation.</li>\n</ul>\n<p>In this part, we will do a brief introduction providing a mostly high-level view of Typescript.\nWe will get into actually working with TypeScript in the <a href=\"/part8/first_steps_with_type_script\">next section</a></p>\n<h3>Main principle</h3>\n<p>TypeScript is a typed superset of JavaScript, and eventually, it's compiled into plain JavaScript code.\nThe programmer is even able to decide the version of the generated code, as long as it's ECMAScript 3 or newer.\nTypeScript being a superset of JavaScript means that it includes all the features of JavaScript and\nits additional features as well.\nIn other words, all existing JavaScript code is valid TypeScript.</p>\n<p>TypeScript consists of three separate, but mutually fulfilling parts:</p>\n<ul>\n<li>The language</li>\n<li>The compiler</li>\n<li>The language service</li>\n</ul>\n<picture><img src=\"/static/de4f555f9967b4c373f40c98d10aa69b/5a190/1.png\" alt=\"diagram of typescript components\" srcset=\"/static/de4f555f9967b4c373f40c98d10aa69b/772e8/1.png 200w,\n/static/de4f555f9967b4c373f40c98d10aa69b/e17e5/1.png 400w,\n/static/de4f555f9967b4c373f40c98d10aa69b/5a190/1.png 800w,\n/static/de4f555f9967b4c373f40c98d10aa69b/69476/1.png 926w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<h4>Language</h4>\n<p>The <strong>language</strong> consists of <em>syntax, keywords and type annotations</em>.\nThe syntax is similar to but not the same as JavaScript syntax.\nFrom the three parts of TypeScript, programmers have the most direct contact with the language.</p>\n<h4>Compiler</h4>\n<p>The <strong>compiler</strong> is responsible for type information erasure (i.e. removing the typing information) and for code transformations.\nThe code transformations enable TypeScript code to be transpiled into executable JavaScript.\n<strong><em>Everything related to the types is removed at compile-time</em></strong>.\nEven though TypeScript isn't statically-typed code in its <em>truest</em> form, it is often still referred to as a statically-typed language.</p>\n<p>Traditionally, <em>compiling</em> means that code is transformed from a human-readable format to a machine-readable format.\nIn TypeScript, human-readable source code is transformed into another human-readable source code, so the correct term would be <strong>transpiling</strong>.\nHowever, compiling has been the most commonly-used term in this context, so we will continue to use it.</p>\n<p>The compiler also performs a static code analysis.\nIt can emit warnings or errors if it finds a reason to do so,\nand it can be set to perform additional tasks such as combining the generated code into a single file.</p>\n<h4>Language Service</h4>\n<p>The <strong>language service</strong> collects type information from the source code.\nDevelopment tools can use the type information for providing IntelliSense, type hints and possible refactoring alternatives.</p>\n<h3>TypeScript key language features</h3>\n<p>This section will describe some of Typescript's key features.\nWe hope to provide you with a basic understanding of TypeScript's\nkey features, which will hopefully help you build a strong foundation for the rest of the course.</p>\n<h4>Type annotations</h4>\n<p>Type annotations in TypeScript are a lightweight way to record the intended <strong><em>contract</em></strong> of a function or a variable.\nIn the example below, we have defined a <code class=\"language-text\">birthdayGreeter</code> function that accepts two arguments: one of type <code class=\"language-text\">string</code> and one of type <code class=\"language-text\">number</code>.\nThe function will return a <code class=\"language-text\">string</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> birthdayGreeter <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> number<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token parameter\">string</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Happy birthday </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, you are now </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> years old!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> birthdayHero <span class=\"token operator\">=</span> <span class=\"token string\">\"Jane User\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> age <span class=\"token operator\">=</span> <span class=\"token number\">22</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">birthdayGreeter</span><span class=\"token punctuation\">(</span>birthdayHero<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>Structural typing</h4>\n<p>TypeScript is a <strong><em>structurally-typed language</em></strong>.\nIn <strong>structural typing</strong>, two elements are considered to be <strong>compatible</strong> with one another if,\nfor each feature within the type of the first element, a corresponding and identical feature exists within the type of the second element (think subset).\nTwo types are considered to be <strong>identical</strong> if they are compatible with each other.</p>\n<h4>Type inference</h4>\n<p>The TypeScript compiler can <em>attempt to infer the type information if no type has been specified</em>.\nVariables' type can be inferred based on their assigned value and their usage.</p>\n<p>The <strong><em>type inference takes place when</em></strong>:</p>\n<ul>\n<li>initializing variables and members</li>\n<li>setting parameter default values</li>\n<li>determining function return types.</li>\n</ul>\n<blockquote>\n<p>For example, consider the function <code class=\"language-text\">add</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* The return value is used to determine\n     the return type of the function */</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The type of the function's return value is inferred by retracing the code back to the return expression, <code class=\"language-text\">return a + b;</code>.\nWe can see that <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are numbers based on their types.\nThus, we can infer the return value for <code class=\"language-text\">add</code> to be of type <code class=\"language-text\">number</code>.</p>\n</blockquote>\n<h4>Type erasure</h4>\n<p>TypeScript removes all type system constructs during compilation.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Typescript</th>\n<th align=\"left\">After Transpile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code class=\"language-text\">let x: SomeType;</code></td>\n<td align=\"left\"><code class=\"language-text\">let x;</code></td>\n</tr>\n</tbody>\n</table>\n<p>This means that <strong><em>no type information remains at runtime</em></strong>.\nAfter transpiling, you are left with <code class=\"language-text\">let x</code>, there is no longer any information about <code class=\"language-text\">x</code> having been of <code class=\"language-text\">SomeType</code>.</p>\n<p>The lack of runtime type information can be surprising for programmers who are used to extensively using reflection or other metadata systems.</p>\n<h3>Why should one use TypeScript?</h3>\n<p>On different forums, you may stumble upon a lot of different arguments either for or against TypeScript.\nThe truth is probably as vague as: it depends on your needs and use of the functions that TypeScript offers.\nHowever, I would advocate for its use - overall it helps constrain our wild tendencies as programmers to</p>\n<ul>\n<li><a href=\"https://xkcd.com/292/\"><em>make</em></a></li>\n<li><a href=\"https://inside.pacific.edu\"><strong>bad</strong></a></li>\n<li><a href=\"https://blog.devgenius.io/the-best-examples-of-bad-code-ive-come-across-production-mode-4f13e8d4de2\"><strong><em>decisions</em></strong></a>.</li>\n</ul>\n<p>Below are some additional explanations on why you should use TypeScript.</p>\n<ol>\n<li>TypeScript offers <strong>type checking and static code analysis</strong>.\n<em>We can require values to be of a certain type, and have the compiler warn about using them incorrectly.</em>\nThis can reduce runtime errors, and you might even be able to reduce the number of required unit tests in a project, at least concerning pure-type tests.\nThe static code analysis doesn't only warn about wrongful type usage,\nbut also other mistakes such as misspelling a variable or function name or trying to use a variable beyond its scope.</li>\n<li>\n<p>Type annotations in the code can function as <strong>code-level documentation</strong>.\nIt's easy to check from a function signature what kind of arguments the function can consume and what type of data it will return.\nThis form of type annotation-bound documentation will always be up to date\nand it makes it easier for new programmers to start working on an existing project.\nIt is also helpful when returning to modify an old project.</p>\n<p><em>Types can be reused all around the code base, and a change to a type definition will automatically be reflected everywhere the type is used</em>.</p>\n<blockquote>\n<p>One might argue that you can achieve similar code-level documentation with e.g. <a href=\"https://jsdoc.app/about-getting-started.html\">JSDoc</a>,\nbut it is not connected to the code as tightly as TypeScript's types, and may thus get out of sync more easily, and is also more verbose.</p>\n</blockquote>\n</li>\n<li>IDEs can provide <strong>improved code hints</strong>\nwhen they know exactly what types of data you are processing.</li>\n</ol>\n<p>All of these features are extremely helpful when you need to refactor your code.\n<strong><em>The static code analysis warns you about any errors in your code,\nand IntelliSense can give you hints about available properties and even possible refactoring options.</em></strong>\nThe code-level documentation helps you understand the existing code.\nWith the help of TypeScript, it is also very easy to start using the newest JavaScript language features at an early stage just by altering its configuration.</p>\n<h3>What does TypeScript not fix?</h3>\n<p>As mentioned above, TypeScript's type annotations and type checking exist only at compile time and no longer at runtime.\nEven if the compiler does not throw any errors, runtime errors are still possible.\nThese runtime errors are especially common when handling external input, such as data received from a network request.</p>\n<p><strong><em>Below are some issues many have with TypeScript, which might be good to be aware of:</em></strong></p>\n<h4>Incomplete, invalid or missing types in external libraries</h4>\n<p>When using external libraries, you may find that <em>some libraries have either missing or in some way invalid type declarations</em>.\nMost often, this is due to the library not being written in TypeScript,\nand the person adding the type declarations manually not doing a good enough job with it.\nIn a few of these cases, <strong><em>you might need to define the type declarations yourself</em></strong>.\nHowever, there is a good chance someone has already added typings for the package you are using.\nAlways check the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped GitHub page</a> first.\nIt is probably the most popular source for type declaration files.\nYou may also want to peruse the PRs by searching for the library you are looking for to get more information on possible issues,\nas the community for generating these types is very active.\nAs a final option, you could also get acquainted with\n<a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html\">TypeScript's documentation</a>\nregarding type declarations.</p>\n<h4>Sometimes, type inference needs assistance</h4>\n<p>The type inference in TypeScript is pretty good but not quite perfect.\nSometimes, you may feel like you have declared your types perfectly,\nbut the compiler still tells you that the property does not exist or that this kind of usage is not allowed.\nIn these cases, you might need to help the compiler out by doing something like an \"extra\" type check,\nbut be careful with type casting (aka type assertion) or type guards.\nWhen using those, *you are giving your word to the compiler that the <strong>value is of the type</strong> that you declare*.\nYou might want to check out TypeScript's documentation regarding <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions\">type assertions</a>\nand <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html\">type guarding/narrowing</a>.</p>\n<h4>Mysterious type errors</h4>\n<p>The errors given by the type system may sometimes be quite hard to understand, especially if you use complex types.\nAs a rule of thumb, the <strong><em>TypeScript error messages have the most useful information at the end of the message</em></strong>.\nWhen running into long confusing messages, start reading them from the end.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/ed8ae98c5d885b4d1928a681eefbe7c4/part-8.svg"},"part":8,"letter":"a","lang":"en"}}},"pageContext":{"part":8,"letter":"a","lang":"en"}}}